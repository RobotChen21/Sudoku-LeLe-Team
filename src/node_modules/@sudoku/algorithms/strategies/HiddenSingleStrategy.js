import { getCandidates } from '../utils/candidates';

export class HiddenSingleStrategy {
	findHint(grid) {
		for (let i = 0; i < 9; i++) {
			const rowHint = this.checkRow(grid, i);
			if (rowHint) return rowHint;

			const colHint = this.checkColumn(grid, i);
			if (colHint) return colHint;
		}

		for (let boxY = 0; boxY < 3; boxY++) {
			for (let boxX = 0; boxX < 3; boxX++) {
				const boxHint = this.checkBox(grid, boxX * 3, boxY * 3);
				if (boxHint) return boxHint;
			}
		}

		return null;
	}

	checkRow(grid, row) {
		const positions = Array(10).fill(0).map(() => []);

		for (let col = 0; col < 9; col++) {
			if (grid[row][col] === 0) {
				const candidates = getCandidates(grid, col, row);
				candidates.forEach(num => positions[num].push([col, row]));
			}
		}

		for (let num = 1; num <= 9; num++) {
			if (positions[num].length === 1) {
				const [x, y] = positions[num][0];
				const relatedCells = this.getRelatedCellsForRow(grid, x, y, num, row);
				return {
					hintType: '隐性唯一法(行)',
					targetCell: [x, y],
					value: num,
					relatedCells,
					reason: `在第 ${row + 1} 行中，数字 ${num} 只能在第 ${y + 1} 行第 ${x + 1} 列填入。`,
				};
			}
		}

		return null;
	}

	checkColumn(grid, col) {
		const positions = Array(10).fill(0).map(() => []);

		for (let row = 0; row < 9; row++) {
			if (grid[row][col] === 0) {
				const candidates = getCandidates(grid, col, row);
				candidates.forEach(num => positions[num].push([col, row]));
			}
		}

		for (let num = 1; num <= 9; num++) {
			if (positions[num].length === 1) {
				const [x, y] = positions[num][0];
				const relatedCells = this.getRelatedCellsForColumn(grid, x, y, num, col);
				return {
					hintType: '隐性唯一法(列)',
					targetCell: [x, y],
					value: num,
					relatedCells,
					reason: `在第 ${col + 1} 列中，数字 ${num} 只能在第 ${y + 1} 行第 ${x + 1} 列填入。`,
				};
			}
		}

		return null;
	}

	checkBox(grid, boxStartX, boxStartY) {
		const positions = Array(10).fill(0).map(() => []);

		for (let dy = 0; dy < 3; dy++) {
			for (let dx = 0; dx < 3; dx++) {
				const x = boxStartX + dx;
				const y = boxStartY + dy;
				if (grid[y][x] === 0) {
					const candidates = getCandidates(grid, x, y);
					candidates.forEach(num => positions[num].push([x, y]));
				}
			}
		}

		for (let num = 1; num <= 9; num++) {
			if (positions[num].length === 1) {
				const [x, y] = positions[num][0];
				const relatedCells = this.getRelatedCellsForBox(grid, x, y, num, boxStartX, boxStartY);
				const boxRow = Math.floor(boxStartY / 3) + 1;
				const boxCol = Math.floor(boxStartX / 3) + 1;
				return {
					hintType: '隐性唯一法(宫)',
					targetCell: [x, y],
					value: num,
					relatedCells,
					reason: `在第 ${boxRow} 行第 ${boxCol} 列的宫中，数字 ${num} 只能在第 ${y + 1} 行第 ${x + 1} 列填入。`,
				};
			}
		}

		return null;
	}

	getRelatedCellsForRow(grid, x, y, num, row) {
		const related = [];

		for (let col = 0; col < 9; col++) {
			if (col !== x && grid[row][col] === num) {
				related.push([col, row]);
			}
		}

		for (let r = 0; r < 9; r++) {
			if (r !== row && grid[r][x] === num) {
				related.push([x, r]);
			}
		}

		const boxX = Math.floor(x / 3) * 3;
		const boxY = Math.floor(y / 3) * 3;
		for (let dy = 0; dy < 3; dy++) {
			for (let dx = 0; dx < 3; dx++) {
				const rx = boxX + dx;
				const ry = boxY + dy;
				if ((rx !== x || ry !== y) && grid[ry][rx] === num) {
					related.push([rx, ry]);
				}
			}
		}

		return related;
	}

	getRelatedCellsForColumn(grid, x, y, num, col) {
		const related = [];

		for (let row = 0; row < 9; row++) {
			if (row !== y && grid[row][col] === num) {
				related.push([col, row]);
			}
		}

		for (let c = 0; c < 9; c++) {
			if (c !== col && grid[y][c] === num) {
				related.push([c, y]);
			}
		}

		const boxX = Math.floor(x / 3) * 3;
		const boxY = Math.floor(y / 3) * 3;
		for (let dy = 0; dy < 3; dy++) {
			for (let dx = 0; dx < 3; dx++) {
				const rx = boxX + dx;
				const ry = boxY + dy;
				if ((rx !== x || ry !== y) && grid[ry][rx] === num) {
					related.push([rx, ry]);
				}
			}
		}

		return related;
	}

	getRelatedCellsForBox(grid, x, y, num, boxStartX, boxStartY) {
		const related = [];

		for (let dy = 0; dy < 3; dy++) {
			for (let dx = 0; dx < 3; dx++) {
				const rx = boxStartX + dx;
				const ry = boxStartY + dy;
				if ((rx !== x || ry !== y) && grid[ry][rx] === num) {
					related.push([rx, ry]);
				}
			}
		}

		for (let c = 0; c < 9; c++) {
			if (c !== x && grid[y][c] === num) {
				related.push([c, y]);
			}
		}

		for (let r = 0; r < 9; r++) {
			if (r !== y && grid[r][x] === num) {
				related.push([x, r]);
			}
		}

		return related;
	}
}
