// src/node_modules/@sudoku/algorithms/strategies/HiddenSingleStrategy.ts

import type { Grid, HintResult, HintStrategy, CellPos } from '../types';
import { getCandidates } from '../utils/candidates';

export class HiddenSingleStrategy implements HintStrategy {
   findHint(grid: Grid): HintResult | null {
    // 检查行列
    for (let i = 0; i < 9; i++) {
      // 检查行
      const rowHint = this.checkRow(grid, i);
      if (rowHint) return rowHint;
      
      // 检查列
      const colHint = this.checkColumn(grid, i);
      if (colHint) return colHint;
    }
    
    // 检查宫
    for (let boxY = 0; boxY < 3; boxY++) {
      for (let boxX = 0; boxX < 3; boxX++) {
        const boxHint = this.checkBox(grid, boxX * 3, boxY * 3);
        if (boxHint) return boxHint;
      }
    }
    
    return null;
  }

  private  checkRow(grid: Grid, row: number): HintResult | null {
    // 跟踪每个数字(1-9)在该行中可放置的位置
    const positions: CellPos[][] = Array(10).fill(0).map(() => []);
    
    for (let col = 0; col < 9; col++) {
      if (grid[row][col] === 0) {
        const candidates = getCandidates(grid, col, row);
        candidates.forEach(num => {
          positions[num].push([col, row]);
        });
      }
    }
    
    // 查找只有一个位置可填的数字
    for (let num = 1; num <= 9; num++) {
      if (positions[num].length === 1) {
        const [x, y] = positions[num][0];
        const relatedCells = this.getRelatedCellsForRow(grid, x, y, num, row);
        return {
          hintType: '隐性唯一法(行)',
          targetCell: [x, y],
          value: num,
          relatedCells,
          reason: `在第 ${row + 1} 行中，数字 ${num} 只能在 (${x + 1}, ${y + 1}) 处填入。`,
        };
      }
    }
    
    return null;
  }

  private  checkColumn(grid: Grid, col: number): HintResult | null {
    // 跟踪每个数字(1-9)在该列中可放置的位置
    const positions: CellPos[][] = Array(10).fill(0).map(() => []);
    
    for (let row = 0; row < 9; row++) {
      if (grid[row][col] === 0) {
        const candidates = getCandidates(grid, col, row);
        candidates.forEach(num => {
          positions[num].push([col, row]);
        });
      }
    }
    
    // 查找只有一个位置可填的数字
    for (let num = 1; num <= 9; num++) {
      if (positions[num].length === 1) {
        const [x, y] = positions[num][0];
        const relatedCells = this.getRelatedCellsForColumn(grid, x, y, num, col);
        return {
          hintType: '隐性唯一法(列)',
          targetCell: [x, y],
          value: num,
          relatedCells,
          reason: `在第 ${col + 1} 列中，数字 ${num} 只能在 (${x + 1}, ${y + 1}) 处填入。`,
        };
      }
    }
    
    return null;
  }

  private checkBox(grid: Grid, boxStartX: number, boxStartY: number): HintResult | null {
    // 跟踪每个数字(1-9)在该宫中可放置的位置
    const positions: CellPos[][] = Array(10).fill(0).map(() => []);
    
    for (let dy = 0; dy < 3; dy++) {
      for (let dx = 0; dx < 3; dx++) {
        const x = boxStartX + dx;
        const y = boxStartY + dy;
        
        if (grid[y][x] === 0) {
          const candidates = getCandidates(grid, x, y);
          candidates.forEach(num => {
            positions[num].push([x, y]);
          });
        }
      }
    }
    
    // 查找只有一个位置可填的数字
    for (let num = 1; num <= 9; num++) {
      if (positions[num].length === 1) {
        const [x, y] = positions[num][0];
        const relatedCells = this.getRelatedCellsForBox(grid, x, y, num, boxStartX, boxStartY);
        return {
          hintType: '隐性唯一法(宫)',
          targetCell: [x, y],
          value: num,
          relatedCells,
          reason: `在第 ${Math.floor(boxStartY/3)+1} 行第 ${Math.floor(boxStartX/3)+1} 列的宫中，数字 ${num} 只能在 (${x + 1}, ${y + 1}) 处填入。`,
        };
      }
    }
    
    return null;
  }

  private  getRelatedCellsForRow(grid: Grid, x: number, y: number, num: number, row: number): CellPos[] {
    const related: CellPos[] = [];
    
    // 同一行中已存在的相同数字
    for (let col = 0; col < 9; col++) {
      if (col !== x && grid[row][col] === num) {
        related.push([col, row]);
      }
    }
    
    // 同一列和同一宫中已存在的相同数字
    for (let r = 0; r < 9; r++) {
      if (r !== row && grid[r][x] === num) {
        related.push([x, r]);
      }
    }
    
    const boxX = Math.floor(x / 3) * 3;
    const boxY = Math.floor(y / 3) * 3;
    for (let dy = 0; dy < 3; dy++) {
      for (let dx = 0; dx < 3; dx++) {
        const rx = boxX + dx;
        const ry = boxY + dy;
        if ((rx !== x || ry !== y) && grid[ry][rx] === num) {
          related.push([rx, ry]);
        }
      }
    }
    
    return related;
  }

  private  getRelatedCellsForColumn(grid: Grid, x: number, y: number, num: number, col: number): CellPos[] {
    const related: CellPos[] = [];
    
    // 同一列中已存在的相同数字
    for (let row = 0; row < 9; row++) {
      if (row !== y && grid[row][col] === num) {
        related.push([col, row]);
      }
    }
    
    // 同一行和同一宫中已存在的相同数字
    for (let c = 0; c < 9; c++) {
      if (c !== col && grid[y][c] === num) {
        related.push([c, y]);
      }
    }
    
    const boxX = Math.floor(x / 3) * 3;
    const boxY = Math.floor(y / 3) * 3;
    for (let dy = 0; dy < 3; dy++) {
      for (let dx = 0; dx < 3; dx++) {
        const rx = boxX + dx;
        const ry = boxY + dy;
        if ((rx !== x || ry !== y) && grid[ry][rx] === num) {
          related.push([rx, ry]);
        }
      }
    }
    
    return related;
  }

  private  getRelatedCellsForBox(grid: Grid, x: number, y: number, num: number, boxStartX: number, boxStartY: number): CellPos[] {
    const related: CellPos[] = [];
    
    // 同一宫中已存在的相同数字
    for (let dy = 0; dy < 3; dy++) {
      for (let dx = 0; dx < 3; dx++) {
        const rx = boxStartX + dx;
        const ry = boxStartY + dy;
        if ((rx !== x || ry !== y) && grid[ry][rx] === num) {
          related.push([rx, ry]);
        }
      }
    }
    
    // 同一行和同一列中已存在的相同数字
    for (let c = 0; c < 9; c++) {
      if (c !== x && grid[y][c] === num) {
        related.push([c, y]);
      }
    }
    
    for (let r = 0; r < 9; r++) {
      if (r !== y && grid[r][x] === num) {
        related.push([x, r]);
      }
    }
    
    return related;
  }
}