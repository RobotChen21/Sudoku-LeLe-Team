// src/node_modules/@sudoku/algorithms/strategies/NakedSingleStrategy.ts

import type { Grid, HintResult, HintStrategy, CellPos} from '../types';
import { getCandidates } from '../utils/candidates';

export class NakedSingleStrategy implements HintStrategy {
  findHint(grid: Grid): HintResult | null {
    for (let y = 0; y < 9; y++) {
      for (let x = 0; x < 9; x++) {
        if (grid[y][x] === 0) {
          const candidates = getCandidates(grid, x, y);
          if (candidates.length === 1) {
            const value = candidates[0];
            const relatedCells = this.getRelatedCells(grid, x, y, value);
            return {
              hintType: '唯余法',
              targetCell: [x, y],
              value,
              relatedCells,
              reason: `在(${x + 1}, ${y + 1})处，通过排除法仅剩数字 ${value} 可填入。`,
            };
          }
        }
      }
    }
    return null;
  }

  private getRelatedCells(grid: Grid, x: number, y: number, value: number): CellPos[] {
    const related: Set<string> = new Set();
    
    // 行中的相关格子
    for (let col = 0; col < 9; col++) {
      if (col !== x && grid[y][col] !== 0) {
        related.add(`${col},${y}`);
      }
    }
    
    // 列中的相关格子
    for (let row = 0; row < 9; row++) {
      if (row !== y && grid[row][x] !== 0) {
        related.add(`${x},${row}`);
      }
    }
    
    // 宫中的相关格子
    const boxX = Math.floor(x / 3) * 3;
    const boxY = Math.floor(y / 3) * 3;
    for (let dy = 0; dy < 3; dy++) {
      for (let dx = 0; dx < 3; dx++) {
        const rx = boxX + dx;
        const ry = boxY + dy;
        if ((rx !== x || ry !== y) && grid[ry][rx] !== 0) {
          related.add(`${rx},${ry}`);
        }
      }
    }

    return Array.from(related).map(coord => {
      const [cx, cy] = coord.split(',').map(Number);
      return [cx, cy] as CellPos;
    });
  }
}